#!/usr/bin/env python3
import contextlib as __scriptmerge_contextlib


@__scriptmerge_contextlib.contextmanager
def __scriptmerge_temporary_dir():
    import tempfile
    import shutil

    dir_path = tempfile.mkdtemp()
    try:
        yield dir_path
    finally:
        shutil.rmtree(dir_path)


with __scriptmerge_temporary_dir() as __scriptmerge_working_dir:

    def __scriptmerge_write_module(path, contents):
        import os, os.path

        def make_package(path):
            parts = path.split("/")
            partial_path = __scriptmerge_working_dir
            for part in parts:
                partial_path = os.path.join(partial_path, part)
                if not os.path.exists(partial_path):
                    os.mkdir(partial_path)
                    with open(os.path.join(partial_path, "__init__.py"), "wb") as f:
                        f.write(b"\n")

        make_package(os.path.dirname(path))

        full_path = os.path.join(__scriptmerge_working_dir, path)
        with open(full_path, "wb") as module_file:
            module_file.write(contents)

    import sys as __scriptmerge_sys

    __scriptmerge_sys.path.insert(0, __scriptmerge_working_dir)
    __scriptmerge_write_module('core/__init__.py', b'')
    __scriptmerge_write_module('core/database.py', b'"""\n# Exemplo de como adicionar um modelo utilizando o SQLModel\n```python\nfrom database import SessionDep, engine\n\nwith SessionDep(engine) as session:\n    session.add(modelo)\n    session.commit()\n    session.refresh(modelo)\n```\n\n"""\n\nimport asyncio\nfrom collections.abc import AsyncGenerator\nfrom typing import Annotated, Any\n\nfrom astrapy import AsyncDatabase, DataAPIClient\nfrom beanie import init_beanie  # type: ignore\nfrom fastapi import Depends\nfrom pymongo import AsyncMongoClient\nfrom sqlalchemy.ext.asyncio import AsyncEngine, create_async_engine\nfrom sqlalchemy.pool import NullPool\nfrom sqlmodel import SQLModel\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom schemas.compras import criar_compras\nfrom schemas.payment_methods import Pagamento  # type: ignore # noqa: F401\nfrom schemas.products import Product\nfrom settings import SETTINGS\n\nasync_engine: AsyncEngine = create_async_engine(\n    f"postgresql+asyncpg://{SETTINGS.DB_USER}:{SETTINGS.PASSWORD}@{SETTINGS.SERVER}:{SETTINGS.PORT}/{SETTINGS.DATABASE}"\n    if not SETTINGS.RELOAD\n    else "sqlite+aiosqlite:///database.db",\n    poolclass=NullPool,  # Para ambientes serverless\n    connect_args={\n        # Desabilita JIT do PostgreSQL para melhor performance em serverless\n        "server_settings": {"jit": "off"},\n        "command_timeout": 60,\n        "timeout": 30,\n    }\n    if not SETTINGS.RELOAD\n    else {},\n)\n\nCassandra_db: AsyncDatabase | None = None\n_beanie_initialized = False\n_mongo_client: AsyncMongoClient | None = None\n_event_loop_id: int | None = None\n\n\nasync def ensure_beanie_initialized() -> None:\n    """Inicializa o Beanie de forma lazy para ambientes serverless"""\n    global _beanie_initialized, _mongo_client, _event_loop_id\n\n    # Detecta se o event loop mudou (comum em serverless)\n    current_loop_id = id(asyncio.get_event_loop())\n\n    if not _beanie_initialized or _event_loop_id != current_loop_id:\n        # Fecha o cliente antigo se existir e o event loop mudou\n        if _mongo_client is not None and _event_loop_id != current_loop_id:\n            try:\n                await _mongo_client.close()  # type: ignore\n            except Exception:  # noqa: S110\n                pass\n\n        # Cria novo cliente para o event loop atual\n        _mongo_client = AsyncMongoClient(  # type: ignore\n            "mongodb+srv://mongo:mongo@6o-semedtre.fpkb99x.mongodb.net/"\n            "?retryWrites=true&w=majority&appName=6o-semedtre"\n        )\n        await init_beanie(database=_mongo_client.projeto, document_models=[Product])  # type: ignore\n        _beanie_initialized = True\n        _event_loop_id = current_loop_id\n\n\nasync def get_async_session() -> AsyncGenerator[Any, AsyncSession]:\n    async with AsyncSession(async_engine, expire_on_commit=False) as session:\n        yield session\n\n\nasync def get_cassandra_session() -> AsyncGenerator[Any, AsyncDatabase]:\n    client = DataAPIClient(\n        SETTINGS.ASTRA_TOKEN if SETTINGS.ASTRA_TOKEN is not None else ""\n    )\n    yield client.get_async_database_by_api_endpoint(\n        SETTINGS.ASTRA_ENDPOINT if SETTINGS.ASTRA_ENDPOINT is not None else "",\n        keyspace="Polyglot",\n    )\n\n\nasync def create_db_and_tables() -> None:\n    await ensure_beanie_initialized()\n\n    async with async_engine.begin() as conn:\n        await conn.run_sync(SQLModel.metadata.create_all)\n\n\nAsyncSessionDep = Annotated[AsyncSession, Depends(get_async_session)]\nCassandraSessionDep = Annotated[AsyncDatabase, Depends(get_cassandra_session)]\n\n\nasync def init_astra_cassandra() -> None:\n    global Cassandra_db\n    # Initialize the client\n    client = DataAPIClient(\n        SETTINGS.ASTRA_TOKEN if SETTINGS.ASTRA_TOKEN is not None else ""\n    )\n    Cassandra_db = client.get_async_database_by_api_endpoint(\n        SETTINGS.ASTRA_ENDPOINT if SETTINGS.ASTRA_ENDPOINT is not None else "",\n        keyspace="Polyglot",\n    )\n\n    print("Connected to Astra DB", Cassandra_db)\n    Cassandra_db.get_collection("compras")\n    await criar_compras(Cassandra_db)\n')
    __scriptmerge_write_module('schemas/__init__.py', b'')
    __scriptmerge_write_module('schemas/compras.py', b'from datetime import datetime\n\nfrom astrapy import AsyncDatabase\nfrom astrapy.info import ColumnType, CreateTableDefinition\nfrom pydantic import BaseModel\n\n\nasync def criar_compras(cassadra_db: AsyncDatabase) -> None:\n    try:\n        cassadra_db.get_table("compras")\n        print("Tabela \'compras\' j\xc3\xa1 existe, pulando cria\xc3\xa7\xc3\xa3o")\n        return\n    except Exception:\n        print("Tabela \'compras\' n\xc3\xa3o existe, criando...")\n\n    await cassadra_db.create_table(\n        name="compras",\n        definition=CreateTableDefinition.builder()\n        .add_column("user_id", ColumnType.INT)\n        .add_column("quantidade", ColumnType.INT)\n        .add_column("product_id", ColumnType.TEXT)\n        .add_column("data_compra", ColumnType.TIMESTAMP)\n        .add_column("valor_pago", ColumnType.DECIMAL)\n        .add_column("valor_produto", ColumnType.DECIMAL)\n        .add_partition_by(["user_id", "data_compra", "product_id"])\n        .build(),\n    )\n    print("tabela criada")\n\n\nclass Compras(BaseModel):\n    user_id: int\n    product_id: str\n    quantidade: int\n    data_compra: datetime\n    valor_pago: float\n    valor_produto: float\n')
    __scriptmerge_write_module('schemas/payment_methods.py', b'from datetime import datetime\n\nfrom sqlmodel import Field, Relationship, SQLModel\n\nfrom schemas.user import User, UserPublic\n\n\nclass PagamentoCreateLogin(SQLModel):\n    numero_cartao: str\n    nome_titular: str\n    data_validade: datetime\n    cod_seguranca: int\n\n\nclass PagamentoCreate(SQLModel):\n    user_id: int\n    numero_cartao: str\n    nome_titular: str\n    data_validade: datetime\n    cod_seguranca: int\n\n\nclass Pagamento(PagamentoCreate, table=True):\n    id: int | None = Field(default=None, primary_key=True)\n    numero_cartao: str = Field(unique=True)\n    user_id: int = Field(default=None, foreign_key="user.id")\n    user: User = Relationship(back_populates="pagamentos")\n    created_at: datetime = Field(default=datetime.now())\n    updated_at: datetime | None = Field(default=None)\n\n\nclass PagamentoPublic(PagamentoCreate):\n    id: int | None\n    numero_cartao: str\n    user_id: int\n    created_at: datetime\n    updated_at: datetime | None\n\n\nclass PagamentoWithRelations(PagamentoPublic):\n    user: UserPublic\n')
    __scriptmerge_write_module('schemas/user.py', b'from datetime import datetime\nfrom typing import TYPE_CHECKING\n\nfrom sqlmodel import Field, Relationship, SQLModel\n\nif TYPE_CHECKING:\n    from schemas.payment_methods import Pagamento, PagamentoPublic\n\n\nclass UserCreate(SQLModel):\n    name: str\n    username: str = Field(unique=True)\n    email: str\n    age: int\n    cpf: str\n    password: str\n    endereco: str\n\n\nclass User(UserCreate, table=True):\n    id: int = Field(primary_key=True)\n    is_admin: bool = Field(default=False)\n    pagamentos: list["Pagamento"] = Relationship(back_populates="user")\n    created_at: datetime = Field(default=datetime.now())\n    updated_at: datetime | None = Field(default=None)\n\n\nclass UserPublic(UserCreate):\n    id: int | None\n    is_admin: bool\n    created_at: datetime\n    updated_at: datetime | None\n\n\nclass UserWithRelations(UserPublic):\n    pagamentos: list["PagamentoPublic"] | None\n')
    __scriptmerge_write_module('schemas/products.py', b'from datetime import datetime\nfrom typing import Annotated\n\nfrom beanie import Document, Indexed  # type: ignore\nfrom pydantic import BaseModel, Field\n\n\nclass ProductCreate(BaseModel):\n    nome: str\n    preco: float\n    marca: str\n    desc: str | None = None\n    image_url: str | None = None\n    product_id: str\n    created_at: datetime = Field(default=datetime.now())\n\n\nclass Product(Document):\n    owner_id: int\n    nome: str\n    preco: float\n    marca: str\n    desc: str | None = None\n    image_url: str | None = None\n    created_at: datetime = Field(default=datetime.now())\n    product_id: Annotated[str, Indexed(unique=True)]\n    updated_at: datetime | None = None\n\n\nclass ProductUpdate(BaseModel):\n    nome: str | None\n    preco: float | None\n    marca: str | None\n    desc: str | None\n    image_url: str | None\n')
    __scriptmerge_write_module('settings.py', b'from dotenv import load_dotenv\nfrom pydantic_settings import BaseSettings\n\nload_dotenv()\n\n\nclass Settings(BaseSettings):\n    # model_config = SettingsConfigDict(env_file="../.env", env_file_encoding="utf-8")\n\n    SERVER: str | None = None\n    DATABASE: str | None = None\n    DB_USER: str | None = None\n    PASSWORD: str | None = None\n    PORT: str | None = None\n    SECRET_KEY: str | None = None\n    LOG_LEVEL: str = "INFO"\n    RELOAD: bool = False\n    ALGORITHM: str | None = None\n    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30\n    KEY_PEM: str | None = None\n    ASTRA_TOKEN: str | None = None\n    ASTRA_ENDPOINT: str | None = None\n    ASTRA_CLIENTE_ID: str | None = None\n    CERT_PEM: str | None = None\n\n\nSETTINGS = Settings()  # type: ignore\n')
    __scriptmerge_write_module('routes/__init__.py', b'')
    __scriptmerge_write_module('routes/compras.py', b'import datetime\nfrom collections.abc import Iterable\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends\n\nfrom core.auth import get_current_user\nfrom core.database import CassandraSessionDep\nfrom schemas.compras import Compras\nfrom schemas.user import User\n\nrouter = APIRouter(prefix="/compras", tags=["vendas"])\n\n\n@router.post("/")\nasync def create_compra(\n    compra: Compras,\n    current_user: Annotated[User, Depends(get_current_user)],\n    cassandra_db: CassandraSessionDep,\n) -> Compras:\n    tabela = cassandra_db.get_table("compras")\n    resultado = await tabela.insert_one(compra.model_dump())\n    print(resultado)\n    return compra\n\n\n@router.get("/{user_id}")\nasync def get_compras(\n    user_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    cassandra_db: CassandraSessionDep,\n) -> list[Compras]:\n    table = cassandra_db.get_table("compras")\n    result: Iterable[Compras] | object = await table.find(\n        {"$and": [{"user_id": user_id}]}\n    ).to_list()\n    for resultado in result:\n        print(resultado)\n        resultado["data_compra"] = resultado["data_compra"].to_datetime(tz=datetime.UTC)\n        print(Compras(**resultado))\n\n    return list(result)\n')
    __scriptmerge_write_module('core/auth.py', b'from datetime import UTC, datetime, timedelta\nfrom typing import Annotated, Any, Literal\n\nimport jwt\nfrom fastapi import Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordBearer\nfrom jwt import InvalidTokenError\nfrom passlib.context import CryptContext\nfrom sqlmodel import select\nfrom sqlmodel.ext.asyncio.session import AsyncSession\n\nfrom core.database import AsyncSessionDep\nfrom schemas.token import TokenData\nfrom schemas.user import User\nfrom settings import SETTINGS\n\nSECRET_KEY = SETTINGS.SECRET_KEY\nALGORITHM = SETTINGS.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = SETTINGS.ACCESS_TOKEN_EXPIRE_MINUTES\n\noauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")\npwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")\n\n\nasync def get_current_user(\n    token: Annotated[str, Depends(oauth2_scheme)], session: AsyncSessionDep\n) -> User:\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED,\n        detail="Could not validate credentials",\n        headers={"WWW-Authenticate": "Bearer"},\n    )\n    try:\n        payload = jwt.decode(  # type: ignore\n            token,\n            SETTINGS.SECRET_KEY,  # type: ignore\n            algorithms=[SETTINGS.ALGORITHM],  # type: ignore\n        )\n        email = payload.get("sub")\n        if email is None:\n            raise credentials_exception\n        token_data = TokenData(email=email)\n    except InvalidTokenError as e:\n        raise credentials_exception from e\n    user = (\n        await session.exec(select(User).where(User.email == token_data.email))\n    ).first()\n    if user is None:\n        raise credentials_exception\n    return user\n\n\nasync def get_current_admin(\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> User:\n    if not current_user.is_admin:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED, detail="User not admin"\n        )\n    return current_user\n\n\ndef verify_password(plain_password: str, hashed_password: str) -> bool:\n    return pwd_context.verify(plain_password, hashed_password)\n\n\ndef get_password_hash(password: str) -> str:\n    return pwd_context.hash(password)\n\n\nasync def authenticate_user(\n    username: str, password: str, session: AsyncSession\n) -> User | Literal[False]:\n    user = (await session.exec(select(User).where(User.username == username))).first()\n    if not user:\n        return False\n    if not verify_password(password, user.password):\n        return False\n    return user\n\n\ndef create_access_token(\n    data: dict[str, Any], expires_delta: timedelta | None = None\n) -> str:\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.now(UTC) + expires_delta\n    else:\n        expire = datetime.now(UTC) + timedelta(minutes=15)\n    to_encode.update({"exp": expire})  # type: ignore\n    return jwt.encode(to_encode, SETTINGS.SECRET_KEY, algorithm=SETTINGS.ALGORITHM)  # type: ignore\n')
    __scriptmerge_write_module('schemas/token.py', b'from pydantic import BaseModel\n\n\nclass Token(BaseModel):\n    """\n    Schema para o token\n    """\n\n    access_token: str\n    token_type: str\n\n\nclass TokenData(BaseModel):\n    email: str | None = None\n')
    __scriptmerge_write_module('routes/payment_methods.py', b'from typing import TYPE_CHECKING, Annotated\n\nfrom fastapi import APIRouter, Depends\nfrom sqlalchemy.orm import selectinload\nfrom sqlmodel import select\n\nfrom core.auth import get_current_admin\nfrom core.database import AsyncSessionDep\nfrom schemas.payment_methods import Pagamento, PagamentoCreate, PagamentoWithRelations\nfrom schemas.user import User\nfrom utils.relational_utils import create_item, get_item_or_404\n\nif TYPE_CHECKING:\n    from sqlalchemy import ScalarResult\n\nrouter = APIRouter(prefix="/payment_method", tags=["payment_method"])\n\n\n@router.post("/")\nasync def create_payment(\n    metodo: PagamentoCreate,\n    current_user: Annotated[User, Depends(get_current_admin)],\n    session: AsyncSessionDep,\n) -> Pagamento:\n    await get_item_or_404(session, User, metodo.user_id)\n    metodo.data_validade = metodo.data_validade.replace(tzinfo=None)\n    pagamento = Pagamento(**metodo.model_dump())\n    return await create_item(session, Pagamento, pagamento.model_dump())\n\n\n@router.get("/", response_model=list[PagamentoWithRelations])\nasync def get_payments(\n    current_user: Annotated[User, Depends(get_current_admin)],\n    session: AsyncSessionDep,\n) -> list[PagamentoWithRelations]:\n    lista: ScalarResult[Pagamento] = (  # type: ignore\n        await session.exec(select(Pagamento).options(selectinload(Pagamento.user)))  # type: ignore\n    ).all()  # type: ignore\n    return lista  # type: ignore\n')
    __scriptmerge_write_module('utils/__init__.py', b'')
    __scriptmerge_write_module('utils/relational_utils.py', b'from collections.abc import Sequence\nfrom datetime import datetime\nfrom typing import Any\n\nfrom fastapi import HTTPException, status\nfrom sqlmodel import SQLModel, select\n\nfrom core.database import AsyncSession\n\n# Decorator para logar o retorno da fun\xc3\xa7\xc3\xa3o e verificar se ocorreu algum erro\n\n\nasync def create_item[T](\n    session: AsyncSession, model: type[T], data: dict[str, Any]\n) -> T:\n    """Helper gen\xc3\xa9rico para criar"""\n    if hasattr(model, "created_at"):\n        data["created_at"] = datetime.now()\n    if hasattr(model, "updated_at"):\n        data["updated_at"] = datetime.now()\n\n    item: T = model(**data)\n    session.add(item)\n    await session.commit()\n    await session.refresh(item)\n    return item\n\n\nasync def get_item_or_404[T](\n    session: AsyncSession, model: type[T], item_id: int | float | str\n) -> T | None:\n    """Helper gen\xc3\xa9rico para buscar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    return item\n\n\nasync def update_item[T](\n    session: AsyncSession, model: type[T], data: dict[str, Any]\n) -> T | None:\n    item = await get_item_or_404(session, model, data["id"])\n    for key, value in data.items():\n        setattr(item, key, value)\n    session.add(item)\n    await session.commit()\n    await session.refresh(item)\n    return item\n\n\nasync def get_all_items[T](\n    session: AsyncSession, model: type[T], **kwargs: dict[Any, Any]\n) -> Sequence[T] | None:\n    """Helper gen\xc3\xa9rico para buscar todos os itens"""\n    query = select(model)\n    for key, value in kwargs.items():\n        query = query.where(getattr(model, key) == value)\n    result = await session.exec(query)\n    return result.all()\n\n\nasync def delete_item[T](\n    session: AsyncSession, model: type[T], item_id: int | str | float\n) -> None:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    await session.delete(item)\n    await session.commit()\n\n\nasync def soft_delete_item[T: SQLModel](\n    session: AsyncSession, model: type[T], item_id: int | str\n) -> None:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_id)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    item.deleted_at = datetime.now()\n    session.add(item)\n    await session.commit()\n\n\nasync def get_all_itens_by_in_clause[T: SQLModel](\n    session: AsyncSession, model: type[T], column: str, ids: list[int]\n) -> Sequence[T]:\n    """Helper gen\xc3\xa9rico para buscar todos os ids"""\n    query = select(model)\n    query = query.where(getattr(model, column).in_(ids))\n    result = await session.exec(query)\n    return result.all()\n\n\nasync def remove_item_from_link_table[T: SQLModel](\n    session: AsyncSession, model: type[T], item_ids: list[int]\n) -> T:\n    """Helper gen\xc3\xa9rico para deletar"""\n    item = await session.get(model, item_ids)\n    if not item:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail=f"{model.__name__} n\xc3\xa3o encontrado",\n        )\n    await session.delete(item)\n    await session.commit()\n    return item\n')
    __scriptmerge_write_module('routes/products.py', b'from datetime import datetime\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom pymongo.errors import DuplicateKeyError\n\nfrom core.auth import get_current_user\nfrom core.database import ensure_beanie_initialized\nfrom schemas.products import Product, ProductCreate, ProductUpdate\nfrom schemas.responses import DeleteResponse\nfrom schemas.user import User\n\nrouter = APIRouter(prefix="/products", tags=["products"])\n\n\n@router.post("/")\nasync def create_product(\n    product: ProductCreate, current_user: Annotated[User, Depends(get_current_user)]\n) -> Product:\n    await ensure_beanie_initialized()\n    produto = Product(\n        **product.model_dump(),\n        owner_id=current_user.id if current_user.id is not None else -1,\n    )\n    try:\n        await produto.insert()\n    except DuplicateKeyError as e:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT, detail="Produto ja existente"\n        ) from e\n\n    return produto\n\n\n@router.get("/")\nasync def get_products(\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> list[Product]:\n    await ensure_beanie_initialized()\n    produtos = Product.find()\n    return await produtos.to_list()\n\n\n@router.get("/{product_id}")\nasync def get_product(\n    product_id: str, current_user: Annotated[User, Depends(get_current_user)]\n) -> Product:\n    await ensure_beanie_initialized()\n    produto = await Product.find_one({"product_id": product_id})\n    if produto is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Product not found by product id",\n        )\n    return produto\n\n\n@router.delete("/{product_id}")\nasync def delete_product(\n    product_id: str, current_user: Annotated[User, Depends(get_current_user)]\n) -> DeleteResponse:\n    await ensure_beanie_initialized()\n    produto = await Product.find_one({"product_id": product_id})\n    if produto is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Product not found by product id",\n        )\n    result = await produto.delete()\n    print(result)\n    return DeleteResponse(message=f"Produto {product_id = } deletado com sucesso")\n\n\n@router.put("/{product_id}")\nasync def put_product(\n    product_id: str,\n    product_data: ProductUpdate,\n    current_user: Annotated[User, Depends(get_current_user)],\n) -> Product:\n    await ensure_beanie_initialized()\n    produto = await Product.find_one({"product_id": product_id})\n    if produto is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Product not found by product id",\n        )\n    if product_data.nome is not None:\n        produto.nome = product_data.nome\n    if product_data.preco is not None:\n        produto.preco = product_data.preco\n    if product_data.marca is not None:\n        produto.marca = product_data.marca\n    if product_data.desc is not None:\n        produto.desc = product_data.desc\n    produto.updated_at = datetime.now()\n    result = await produto.save()\n    print(result)\n    return produto\n')
    __scriptmerge_write_module('schemas/responses.py', b'from pydantic import BaseModel\n\n\nclass DeleteResponse(BaseModel):\n    message: str\n')
    __scriptmerge_write_module('routes/token.py', b'from datetime import timedelta\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom fastapi.security import OAuth2PasswordRequestForm\n\nfrom core.auth import authenticate_user, create_access_token\nfrom core.database import AsyncSessionDep\nfrom schemas.token import Token\nfrom settings import SETTINGS\n\nrouter = APIRouter(prefix="/token", tags=["token"])\n\n\n@router.post("/")\nasync def login_for_access_token(\n    form_data: Annotated[OAuth2PasswordRequestForm, Depends()], session: AsyncSessionDep\n) -> Token:\n    user = await authenticate_user(form_data.username, form_data.password, session)\n    if not user:\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED,\n            detail="Incorrect username or password",\n            headers={"WWW-Authenticate": "Bearer"},\n        )\n    access_token_expires = timedelta(minutes=SETTINGS.ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\n            "sub": user.email,\n        },\n        expires_delta=access_token_expires,\n    )\n    return Token(access_token=access_token, token_type="bearer")  # noqa: S106\n')
    __scriptmerge_write_module('routes/user.py', b'import datetime\nfrom collections.abc import Iterable\nfrom typing import Annotated\n\nfrom fastapi import APIRouter, Depends, HTTPException, status\nfrom sqlalchemy.orm import selectinload\nfrom sqlmodel import select\n\nfrom core.auth import get_current_user, get_password_hash\nfrom core.database import AsyncSessionDep, CassandraSessionDep\nfrom schemas.compras import Compras\nfrom schemas.payment_methods import Pagamento, PagamentoCreateLogin\nfrom schemas.responses import DeleteResponse\nfrom schemas.user import User, UserCreate, UserWithRelations\nfrom utils.relational_utils import create_item\n\nrouter = APIRouter(prefix="/user", tags=["user"])\n\n\nclass UserRegisterError(Exception): ...\n\n\n@router.post("/")\nasync def create_user(user: UserCreate, session: AsyncSessionDep) -> User:\n    user.password = get_password_hash(user.password)\n    user_exist: User | None = (\n        await session.exec(select(User).where(User.username == user.username))\n    ).first()\n    if user_exist is not None:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT, detail="Username already registred"\n        )\n    return await create_item(session, User, user.model_dump())\n\n\n@router.get("/me/")\nasync def read_users_me(\n    current_user: Annotated[User, Depends(get_current_user)], session: AsyncSessionDep\n) -> UserWithRelations:\n    user: User | None = (\n        await session.exec(\n            select(User)\n            .options(selectinload(User.pagamentos))  # type: ignore\n            .where(User.id == current_user.id)\n        )\n    ).first()\n    if user is None:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="User n\xc3\xa3o encontrado",\n        )\n    return user  # type: ignore\n\n\n@router.post("/payment_method")\nasync def create_payment(\n    metodo: PagamentoCreateLogin,\n    current_user: Annotated[User, Depends(get_current_user)],\n    session: AsyncSessionDep,\n) -> Pagamento:\n    metodo_verificando = await session.exec(\n        select(Pagamento).where(Pagamento.numero_cartao == metodo.numero_cartao)\n    )\n    if len(metodo_verificando.all()) != 0:\n        raise HTTPException(\n            status_code=status.HTTP_409_CONFLICT,\n            detail="Method already registred, try with another card number",\n        )\n\n    metodo.data_validade = metodo.data_validade.replace(tzinfo=None)\n    pagamento = Pagamento(**metodo.model_dump(), user_id=current_user.id)\n    return await create_item(session, Pagamento, pagamento.model_dump())\n\n\n@router.get("/payment_method/{payment_id}")\nasync def get_payment(\n    payment_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    session: AsyncSessionDep,\n) -> Pagamento:\n    pagamento = (\n        await session.exec(\n            select(Pagamento)\n            .where(Pagamento.id == payment_id)\n            .where(Pagamento.user_id == current_user.id)\n        )\n    ).first()\n    if not pagamento:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Metodo de pagamento n\xc3\xa3o encontrado pelo ID",\n        )\n\n    return pagamento\n\n\n@router.get("/payment_method")\nasync def get_payments(\n    current_user: Annotated[User, Depends(get_current_user)],\n    session: AsyncSessionDep,\n) -> list[Pagamento]:\n    pagamentos = (\n        await session.exec(\n            select(Pagamento).where(Pagamento.user_id == current_user.id)\n        )\n    ).fetchall()\n    if not pagamentos:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Metodo de pagamento n\xc3\xa3o encontrado pelo ID",\n        )\n\n    return list[Pagamento](pagamentos)\n\n\n@router.delete("/payment_method/{payment_id}")\nasync def delete_payment(\n    payment_id: int,\n    current_user: Annotated[User, Depends(get_current_user)],\n    session: AsyncSessionDep,\n) -> DeleteResponse:\n    pagamento = (\n        await session.exec(\n            select(Pagamento)\n            .where(Pagamento.id == payment_id)\n            .where(Pagamento.user_id == current_user.id)\n        )\n    ).first()\n    if not pagamento:\n        raise HTTPException(\n            status_code=status.HTTP_404_NOT_FOUND,\n            detail="Metodo de pagamento n\xc3\xa3o encontrado pelo ID",\n        )\n    await session.delete(pagamento)\n    await session.commit()\n\n    return DeleteResponse(message="Payment method deleted sucesfully")\n\n\n@router.get("/compras")\nasync def get_compras_user(\n    current_user: Annotated[User, Depends(get_current_user)],\n    cassandra_db: CassandraSessionDep,\n) -> list[Compras]:\n    table = cassandra_db.get_table("compras")\n    result: Iterable[Compras] | object = await table.find(\n        {"$and": [{"user_id": current_user.id}]}\n    ).to_list()\n    for resultado in result:\n        print(resultado)\n        resultado["data_compra"] = resultado["data_compra"].to_datetime(tz=datetime.UTC)\n        print(Compras(**resultado))\n\n    return list(result)\n')
    from contextlib import asynccontextmanager
    from typing import Any
    
    from fastapi import FastAPI
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.openapi.utils import get_openapi
    from uvicorn import run
    
    from core.database import create_db_and_tables, init_astra_cassandra
    from routes import compras, payment_methods, products, token, user
    from schemas.payment_methods import PagamentoPublic  # type: ignore # noqa: F401
    from schemas.user import UserWithRelations
    from settings import SETTINGS
    
    UserWithRelations.model_rebuild()
    
    
    @asynccontextmanager
    async def lifespan(app: FastAPI):
        await create_db_and_tables()
        await init_astra_cassandra()
    
        yield
    
    
    app = FastAPI(lifespan=lifespan)
    
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"],
        allow_headers=["*"],
    )
    app.include_router(token.router)
    app.include_router(user.router)
    app.include_router(payment_methods.router)
    app.include_router(products.router)
    app.include_router(compras.router)
    
    
    def custom_openapi() -> dict[str, Any]:
        if app.openapi_schema:
            return app.openapi_schema
        openapi_schema: dict[str, Any] = get_openapi(
            title="Polyglot BACKEND",
            version="1.0.0",
            summary="Sistema de e-comercie",
            description="""Trabalho de estudo para a criacao de uma api onde se
             comunica com varios bancos de dados, entre eles, postgres, mongo db
              e cassandra""",
            routes=app.routes,
        )
        app.openapi_schema = openapi_schema
        return app.openapi_schema
    
    
    app.openapi = custom_openapi
    
    if __name__ == "__main__":
        run(
            "main:app",
            host="0.0.0.0",
            reload=True,
            port=8000,
            ssl_certfile=SETTINGS.CERT_PEM,
            ssl_keyfile=SETTINGS.KEY_PEM,
        )
    